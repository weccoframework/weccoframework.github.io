{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This site documents the use of <code>@weccoframework/core</code></p> <p><code>weccoframework/core</code> - called <code>wecco</code> - is a web application framework based  on web standards such as Web Components,  HTML Templates  and plain JavaScript that features</p> <ul> <li>simplicity</li> <li>performance</li> <li>small footprint (under 60k uncompressed)</li> </ul> <p><code>wecco</code> features a functional programming style as opposed to a class based  approach using inheritence that other common web frameworks endorse. Using  functions to express a dynamic web UI allows a developer to focus on a  descriptive approach, where as classes tend to obfuscate the concepts behind a dynamic UI.</p> <p><code>wecco</code> provides both a view engine, that renders views based on models as well as a full application framework that is based on the Model, View, Update architecture pattern.</p> <p><code>wecco</code> is written using TypeScript and can be used from TypeScript projects as well as plain JavaScript ones.</p> <p>Besides a couple of development tools (such as TypeScript, mocha, ...) <code>wecco</code> uses no dependencies (all dependencies are declared as <code>devDependencies</code> in the <code>package.json</code>). This means, that adding <code>wecco</code> to your project does not bloat your <code>node_modules</code>.</p> <p> wecco is stil under heavy development and the API is not  considered stable until release 1.0.0.</p>"},{"location":"#author","title":"Author","text":"<p>wecco is written by Alexander Metzner alexander.metzner@gmail.com.</p>"},{"location":"#license","title":"License","text":"<p>Copyright (c) 2019 - 2025 The wecco authors.</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"installation/","title":"Installation","text":"<p><code>wecco</code> is currently not available from a CDN, so you are required to bundle it with your web application. If you are using <code>npm</code> (or any of the compatible tools, such as <code>pnpm</code> or <code>yarn</code>) you can add <code>wecco</code> as a dependency. This is the recommended way.</p> <p>If you do not use <code>npm</code> you can manually add <code>wecco</code> as a <code>&lt;script&gt;</code> tag to your HTML.</p>"},{"location":"installation/#npm","title":"NPM","text":"<p><code>wecco</code> is available via npm as <code>@weccoframework/core</code>. Simply add it to the <code>dependencies</code> section of your <code>package.json</code>.</p>"},{"location":"installation/#directly-embedding-in-a-html-page","title":"Directly embedding in a HTML page","text":"<p>You can include the a bundled version of <code>wecco</code> into your web application. Simply go to the releases and download the latest version of either the <code>es6</code> or <code>es5</code> bundle. To test a version, you can directly load the bundle from the github downloads, i.e.</p> <pre><code>&lt;script src=\"https://github.com/weccoframework/core/releases/download/v0.25.0/weccoframework-core.min.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Please note, that this is not recommended for any kind of production systems and should only be used during development.</p>"},{"location":"usage/","title":"Usage","text":"<p>This page gives you an overview of how <code>wecco</code> can be used. This is your page to go especially of you are new to <code>wecco</code>. If you have specific questions concerning the API the JavaScript API has an in-depth reference. For questions on how to write template strings see the  HTML template reference.</p>"},{"location":"usage/#a-wecco-application","title":"A <code>wecco</code> application","text":"<p>The following code contains a full \"app\" for a button that counts the number of times a user clicked it.</p> <pre><code>import * as wecco from \"@weccoframework/core\"\n\nclass Model {\n    constructor(public readonly count: number, public readonly explanation: string) {}\n\n    inc() {\n        return new Model(this.count + 1, this.explanation)\n    }\n}\n\ntype Message = \"inc\"\n\nfunction update({model}: wecco.UpdaterContext&lt;Model, Message&gt;): Model {\n    return model.inc()\n}\n\nfunction view ({ emit, model }: wecco.ViewContext&lt;Model, Message&gt;) {\n    return wecco.html`\n    &lt;p class=\"text-sm\"&gt;${model.explanation}&lt;/p&gt;\n    &lt;p&gt;\n        &lt;button \n            class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\"\n            @click=${() =&gt; emit(\"inc\")}&gt;\n            You clicked me ${model.count} times\n        &lt;/button&gt;\n    &lt;/p&gt;`\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", () =&gt; {\n    wecco.createApp(() =&gt; new Model(0, \"Click the button to increment the counter.\"), update, view)\n        .mount(\"#count-clicks-app\")\n})\n</code></pre> <p><code>wecco</code> apps use the Model-View-Update architecture pattern. This pattern separates the logic into a model that gets rendered via view functions. Updates to the model happen via a central update function.</p> <p>In the example above the <code>Model</code> class represents the model: a simple counter. Note that <code>inc</code> method the provides the \"business capabilities\" of the model.</p> <p>An instance of the model will be rendered by the <code>view</code> function. This  function is called by <code>wecco</code> with the current model instance and a <code>context</code> which can be used to emit update messages. The view function uses a tagged template string to create the HTML. The template tag <code>wecco.html</code> is very powerful. It compiles the template string into a hidden HTML <code>&lt;template&gt;</code> element and reuses that everytime the view function is executed. While this allows the developer to simple return a template string, under the hood a lot of caching and reusing is happening to only update what is changed.</p> <p>The <code>update</code> function is responsible for executing updates on the model. This function is called by <code>wecco</code> everytime an update <code>Message</code> is emitted. The function receives the current model instance and the message and provides a new (or updated) model reference which will then get rendered again.</p> <p>The call to <code>wecco.app</code> brings these functions together and starts the app. The rendered content will go to the element identified by the CSS expression <code>#count-clicks-app</code>. The first parameter is the \"model initializer\". This function is called once at the very start of the app to produce the initial model. Use this function to implement URL routing or restore a previous model from the local or session storage.</p>"},{"location":"usage/#a-custom-element","title":"A custom element","text":"<p><code>wecco</code> also provides a simple API for defining custom elements. These can be used standalone or as part of an app.</p> <p>Here is the same count clicks example with a custom element:</p> <pre><code>import * as wecco from \"@weccoframework/core\"\n\ninterface CountClicks {\n    count?: number\n}\n\nconst CountClicks = wecco.define(\"count-clicks\", ({ data, requestUpdate }: wecco.RenderContext&lt;CountClicks&gt;) =&gt; {\n    data.count = data.count ?? 0\n\n    return wecco.html`&lt;p&gt;\n        &lt;button \n            class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\" \n            @click=${() =&gt; { data.count++; requestUpdate() }}&gt;\n            You clicked me ${data.count} times\n        &lt;/button&gt;\n    &lt;/p&gt;`\n}, {\n    observedAttributes: [\"count\"],\n})\n</code></pre> <p><code>wecco.define</code> is used to define a custom element. It returns a factory function that can be used to create instances of the web component. In addition it registers the custom element's name so that HTML references to the element will be resolved.</p> <p>The first parameter to <code>wecco.define</code> defines the name of the component and must follow the custom webcomponent's conventions (i.e. it must contain a dash).</p> <p>The second parameter is the render callback. The render callback is called everytime the component should update.</p> <p>The render callback receives a render context argument, which by convention is deconstructed to receive the properties, the render callback's implementation uses. This usually is the <code>data</code> property, which contains the data to be rendered. The type of data equals the Typescript this parameter's type is defined using a generic type parameter. You commonly use an interface to describe the type. </p> <p>The second property usually used is the notify update callback. It can be used to notify the component that something has changed and the component should update its content. We use this callback to notify when the user has clicked the button and we updated the <code>data</code>-attribute <code>count</code>.</p> <p>In the example above, the element get's used from the HTML</p> <pre><code>&lt;div&gt;\n    &lt;h3 class=\"font-bold mb-2\"&gt;Custom Element&lt;/h3&gt;\n    &lt;p class=\"text-sm\"&gt;Click the button below to update its counter.&lt;/p&gt;\n    &lt;count-clicks count=\"1\" /&gt;\n&lt;/div&gt;\n</code></pre> <p>Note the <code>count=\"1\"</code> attribute to provide an initial value for the counter.</p> <p>Check out the examples to see these two in action as well as the classical todo app.</p>"},{"location":"reference/api/","title":"API reference","text":"<p>This page provides a reference to the Javascript API for <code>wecco</code>.</p>"},{"location":"reference/api/#apps","title":"Apps","text":"<p><code>wecco</code> apps are a combination of view functions, data models and mutations on those models in combination with a well-defined lifecycle that causes the views to be invoked any time the data changes. Those apps follow the model-view-update architecture pattern which is often described as the elm architecture.</p>"},{"location":"reference/api/#contexts","title":"Contexts","text":"<p><code>wecco</code> apps use an idiom called contexts which means, that all functions that make up an app and which are called by the framework receive a context parameter which contains data and callbacks for each app part. </p> <p>In <code>wecco</code>, by convention, a context parameter is usually handled via object deconstruction, cherry-picking only those properties needed.</p> <p>The following sections describe the types of context and their usage.</p>"},{"location":"reference/api/#view","title":"View","text":"<p>A view defines how the UI looks (i.e. which HTML elements to render) given some data (the model).</p> <p>A view is just a function that conforms to the following type definition:</p> <pre><code>type View&lt;MODEL, MESSAGE&gt; = (ctx: ViewContext&lt;MODEL, MESSAGE&gt;) =&gt; ElementUpdate\n\ninterface ViewContext&lt;MODEL, MESSAGE&gt; {\n    emit: MessageEmitter&lt;MESSAGE&gt;\n    get model(): MODEL\n}\n</code></pre> <p>The view function produces an <code>ElementUpdate</code>, which is how <code>wecco</code> updates element's content. This can either be a string, a value returned from the <code>wecco.html</code> string tag, and <code>HTMLElement</code>, <code>null</code> or an array of those values.</p> <p>The context passed to the view contains the <code>model</code> to render as well as a callback <code>emit</code> which is used to emit a message to be handled.</p>"},{"location":"reference/api/#update","title":"Update","text":"<p>An update function mutates the data (the model) based on some input, which is called a message. Think of a message as something like a command pattern object which describes what operation to perform and which arguments to use for this operation.</p> <p>The result of such an update cycle is a (possibly new) version of the data to render.</p> <p>An update function must conform to the following type definition:</p> <pre><code>type Updater&lt;MODEL, MESSAGE&gt; = (ctx: UpdaterContext&lt;MODEL, MESSAGE&gt;) =&gt; ModelResult&lt;MODEL&gt;\n\nexport interface UpdaterContext&lt;MODEL, MESSAGE&gt; extends ViewContext&lt;MODEL, MESSAGE&gt; {\n    get message(): MESSAGE\n}\n</code></pre> <p>Notice the return type <code>ModelResult&lt;MODEL&gt;</code>. This type union includes instances of <code>MODEL</code>, <code>Promises</code> that resolve to a <code>MODEL</code> as well as the sentinel <code>NoModelChange</code> value (which signals, that nothing needs to be updated).</p>"},{"location":"reference/api/#weccocreateapp","title":"<code>wecco.createApp</code>","text":"<p>Creates a new app. The arguments define the app's model, view and update handler.</p> <ul> <li><code>modelInitializer</code> - initializer to create the initial model - either synchronously or asynchronously</li> <li><code>updater</code> - applies update messages to the model - either synchronously or asynchronously</li> <li><code>view</code> - renders the model - always synchronously</li> </ul> <p>The function returns an <code>App</code> (see below) that can be used to control the app by emitting messages.</p> <p>The following \"sketch\" shows the \"wireframe\" for each app:</p> <pre><code>type Model = // ...\n\ntype Message = // ...\n\nfunction update({model}: wecco.UpdaterContext&lt;Model, Message&gt;): Model {\n    // ...\n}\n\nfunction view ({ emit, model }: wecco.ViewContext&lt;Model, Message&gt;): wecco.ElementUpdate {\n    return wecco.html`\n        ...\n    `\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", () =&gt; {\n    wecco.createApp(() =&gt; /* some model value */, update, view)\n        .mount(\"#app\")\n})\n</code></pre>"},{"location":"reference/api/#weccoapp","title":"<code>wecco.App</code>","text":"<p>An <code>App</code> is returned from <code>wecco.createApp</code>. It provides two methods:</p> <ul> <li><code>mount</code> - which \"mounts\" the app onto some HTML element</li> <li><code>emit</code> - which can be used to send messages to the app used to control     the app from the outside.</li> </ul> <pre><code>interface App&lt;M&gt; {\n    mount(mountPoint: ElementSelector): void\n    emit(message: M): void\n}\n</code></pre>"},{"location":"reference/api/#wecconomodelchange","title":"<code>wecco.NoModelChange</code>","text":"<p>A sentinel value representing the updater's decision not to update the model and skip the re-rendering cycle. May be returned from an <code>update</code> function to indicate that side effects happend (such as updating the storage) but no re-rendering is needed.</p>"},{"location":"reference/api/#custom-elements","title":"Custom Elements","text":""},{"location":"reference/api/#weccodefine","title":"<code>wecco.define</code>","text":"<p><code>define</code> is used to define a new web component which is also a custom web element. The function accepts the following arguments:</p> <ul> <li><code>name</code> - the name of the custom element. This name is used as the custom     element's tag name, so it must follow the custom element specs (i.e. the     name must contain a dash)</li> <li><code>renderCallback</code> - the render callback will be called whenever the element<code>s     content needs to be updated. The callback receives a</code>RenderContext` parameter     (see below) which, by convention, is handled by object deconstruction.</li> <li><code>options</code> - an optional options object. See below for additional information</li> </ul> <p>The value returned from <code>define</code> is an instance of a <code>ComponentFactory</code> which can produce instances of the defined component by passing in initial data.</p> <pre><code>const CountClicks = wecco.define&lt;number&gt;(\"count-clicks\", ...)\n\n// ...\n\nconst countClicksElement = CountClicks(3)\nsomeHTMLElement.appendChild(countClicksElement)\n</code></pre>"},{"location":"reference/api/#render-callback","title":"Render Callback","text":"<p>The context passed to each invocation of the render callback, follows the following interface:</p> <pre><code>interface RenderContext&lt;T&gt; {\n    get data(): T\n\n    requestUpdate: () =&gt; void\n\n    emit: (event: string, payload?: any) =&gt; void\n\n    addEventListener: (event: string, listener: (payload?: any) =&gt; void) =&gt; void\n\n    once: (id: string, callback: OnceCallback) =&gt; void\n}\n</code></pre> <ul> <li><code>data</code> - getter to get the data to be rendered. Almost all custom elements use this</li> <li><code>requestUpdate</code> - a callback to be bound to some trigger from within the rendered HTML.     Invoking this callback signals to the framework that <code>data</code> has been updated and     rendering should be triggered again for the element's rendered content to reflect     this change. As with <code>data</code>, almost all custom elements use this.</li> <li><code>emit</code> - can be used to emit a <code>CustomEvent</code> from the element.     Pass in the event's name and an (optional payload). This method is especially     usefull when using custom events.</li> <li><code>addEventListener</code> - used to subscribe for <code>CustomEvent</code>s.</li> <li><code>once</code> - register some callback to be called exactly once for each instance     of the element. Use this to register a callback that, loads inital data (i.e.     via <code>fetch</code>) or register timeouts, intervals, ...</li> </ul>"},{"location":"reference/api/#options","title":"Options","text":"<p>You can pass an optional <code>options</code> parameter to <code>define</code> which supports a two-way binding of <code>data</code> fields to either HTML element attributes or  JavaScript properties of the element. The options type is defined as</p> <pre><code>interface DefineOptions&lt;T&gt; {\n    observedAttributes?: Array&lt;keyof T&gt;\n    observedProperties?: Array&lt;keyof T&gt;\n}\n</code></pre>"},{"location":"reference/api/#full-example","title":"Full Example","text":"<p>The following full example shows a simple click-counting button:</p> <pre><code>import * as wecco from \"@weccoframework/core\"\n\ninterface CountClicks {\n    count?: number\n}\n\nconst CountClicks = wecco.define(\"count-clicks\", ({ data, requestUpdate }: wecco.RenderContext&lt;CountClicks&gt;) =&gt; {\n    data.count = data.count ?? 0\n\n    return wecco.html`&lt;p&gt;\n        &lt;button \n            class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\" \n            @click=${() =&gt; { data.count++; requestUpdate() }}&gt;\n            You clicked me ${data.count} times\n        &lt;/button&gt;\n    &lt;/p&gt;`\n}, {\n    observedAttributes: [\"count\"],\n})\n</code></pre>"},{"location":"reference/api/#weccocomponent","title":"<code>wecco.component</code>","text":"<p>Creates an instance of a <code>define</code>d element which will use the given <code>data</code> and will be added to the given <code>host</code> element. This is an alternative approach to using the <code>ComponentFactory</code> returned by <code>define</code> which does not require a handle to the component factory but uses the browser's built-in registry for custom web components.</p> <p>The following two snippets as essentially the same:</p> <pre><code>const SomeComponent = wecco.define(\"some-component\" // ...\n\nSomeComponent({}).mount(\"#body\")\n</code></pre> <p>vs.</p> <pre><code>wecco.define(\"some-component\" // ...\n\nconst componentData = // ...\n\nwecco.component(\"some-component\", componentData).mount(\"#body\")\n</code></pre> <p>The arguments passed to <code>component</code> are:</p> <ul> <li><code>componentName</code> - the component's name</li> <li><code>data</code> - the bound data</li> <li><code>host</code> - the host to add the component to. This is optional; you can leave     it out and add the element to the DOM by any other means.</li> </ul>"},{"location":"reference/api/#rendering-html","title":"Rendering HTML","text":""},{"location":"reference/api/#weccoupdateelement","title":"<code>wecco.updateElement</code>","text":"<p><code>updateElement</code> applies the given update request to the given target.</p> <ul> <li><code>target</code> -  the target to update. This can be a DOM <code>Element</code> or a CSS selector string.</li> <li><code>request</code> - the update \"request\". May be an update function or an <code>ElementUpdater</code>. The following things     can be used: <ul> <li><code>null</code> to remove any content from the target</li> <li><code>string</code> which is used as inner text (note that this is not <code>innerHTML</code>)</li> <li>a DOM <code>Element</code> which gets appended as a child of target</li> <li>a <code>wecco.ElementUpdateFunction</code> which is callback function that receives the target to update</li> <li>a <code>wecco.ElementUpdater</code> an interface for types used internally by wecco (but may be used externally as well).     See the documentation on <code>wecco.html</code> and <code>wecco.shadow</code> below for the most common uses of this type</li> <li>an array of any of the above</li> </ul> </li> <li><code>notifyUpdated</code> whether to send an update event after the element update </li> </ul> <p><code>updateElement</code> emits custom events to notify any subscribers that an update happens/happend. The following events are emitted:</p> <ul> <li><code>updatestart</code> - emitted for the <code>target</code> before update starts</li> <li><code>updateend</code> - emitted for the <code>target</code> adter update ends</li> <li><code>update</code> - emitted for every child nested below <code>target</code> that was visited during the update</li> </ul> <p>Subscribe to those event in case you need to handle custom processing such as managing animations.</p>"},{"location":"reference/api/#weccohtml","title":"<code>wecco.html</code>","text":"<p>Used as a tag for a template string to create an <code>ElementUpdater</code> that updates a DOM node. See HTML tag template string reference for details.</p>"},{"location":"reference/api/#weccoshadow","title":"<code>wecco.shadow</code>","text":"<p>Used to create a HTML <code>ShadowDocument</code> to isolate an element from the surrounding CSS and JavaScript.</p>"},{"location":"reference/html-template-tag/","title":"HTML tag template string reference","text":"<p><code>wecco</code> provides the <code>wecco.html</code> template tag that features easy to use mechanics to render HTML from template strings. The HTML is rendered by the browser using HTML <code>&lt;template&gt;</code> elements that are cached and reused for minimal updates.</p>"},{"location":"reference/html-template-tag/#element-text","title":"Element text","text":"<p>You can use literal text as well as placeholders to generate literal element text.</p> <pre><code>wecco.html`&lt;p&gt;hello, world!&lt;/p&gt;`\n\nwecco.html`&lt;p&gt;${\"hello, world!\"}&lt;/p&gt;`\n\nwecco.html`&lt;p&gt;hello, ${\"world\"}!&lt;/p&gt;`\n\nconst gretee = \"world\";   \nwecco.html`&lt;p&gt;Hello&lt;/p&gt;${gretee}`\n\nwecco.html`&lt;p&gt;${\"hello\"}&lt;/p&gt;${\"world\"}`\n\nconst message = \"Hello,\";\nconst gretee = \"world\";  \nwecco.html`&lt;p&gt;${message} ${gretee}!&lt;/p&gt;`\n</code></pre>"},{"location":"reference/html-template-tag/#attributes","title":"Attributes","text":"<p>You can use placeholders to set the attributes of HTML elements. You can use a single placeholder as the whole attribute's value as well as combine one or more placeholders with literal text.</p> <pre><code>const classes = \"small hero\"\nwecco.html`&lt;p class=${classes}&gt;hello, world!&lt;/p&gt;`\n\nwecco.html`&lt;p class=\"${classes} hero\"&gt;hello, world!&lt;/p&gt;`\n\nwecco.html`&lt;p class=\"${classes} hero ${\"col\"}\"&gt;hello, world!&lt;/p&gt;`\n</code></pre>"},{"location":"reference/html-template-tag/#remove-empty-attributes","title":"Remove empty attributes","text":"<p>If you want to remove an attribute if the placeholder used for the value resolves to <code>null</code>, add a <code>+omitempty</code> suffix to the attribute's name:</p> <pre><code>wecco.html`&lt;p id+omitempty=\"foo ${undefined}\"&gt;&lt;/p&gt;`\n</code></pre>"},{"location":"reference/html-template-tag/#boolean-attributes","title":"Boolean Attributes","text":"<p>Boolean attributes are attributes with a value that doesn't matter. What matters is whether the attribute is present or not. <code>wecco</code> uses a <code>?</code> prefix for the attribute name. The value must be a single placeholder that will be used in a boolean context.</p> <pre><code>wecco.html`&lt;a ?disabled=${false}&gt;hello, world!&lt;/a&gt;`\n</code></pre>"},{"location":"reference/html-template-tag/#properties","title":"Properties","text":"<p><code>wecco.html</code> can also set Javascript properties of an <code>HTMLElement</code> created from a template string. A good example for this is setting the <code>value</code> of an input element or the <code>checked</code> attribute of a checkbox.</p> <pre><code>wecco.html`&lt;input type=\"text\" .value=${\"hello, world\"}&gt;`\n\nwecco.html`&lt;input type=\"checkbox\" .checked=${true} ?disabled=${true}&gt;&lt;input type=\"checkbox\" .checked=${true}&gt;\n</code></pre>"},{"location":"reference/html-template-tag/#add-event-listeners","title":"Add Event Listeners","text":"<p><code>wecco</code> allows you to add event listeners to <code>HTMLElements</code> created from a template by using the event's name prefixed with <code>@</code> as an attribute. The value must be single placeholder that resolves to a valid JavaScript event handler (usually a function).</p> <pre><code>const callback = () =&gt; { clicked = true }\n\nwecco.html`&lt;a @click=${callback}&gt;Hello, world&lt;/a&gt;`\n</code></pre> <p>The event attribute name can be suffixed with any of the following suffixes which customize the event listener registration:</p> Suffix Description <code>+capture</code> Sets the <code>capture</code> property of the Options object passed to <code>addEventListener</code> to <code>true</code> <code>+passive</code> Sets the <code>passive</code> property of the Options object passed to <code>addEventListener</code> to <code>true</code> <code>+once</code> Sets the <code>once</code> property of the Options object passed to <code>addEventListener</code> to <code>true</code> <code>+stoppropagation</code> Creates a wrapper for the listener that calls <code>event.StopPropagation()</code> <code>+stopimmediatepropagation</code> Creates a wrapper for the listener that calls <code>event.StopImmediatePropagation()</code> <code>+preventdefault</code> Creates a wrapper for the listener that calls <code>event.PreventDefault()</code> <pre><code>wecco.html`&lt;div @click=${callback.bind(null, \"div\")}&gt;&lt;a @click+stopPropagation=${callback.bind(null, \"a\")}&gt;Hello, world&lt;/a&gt;&lt;/div&gt;`\n</code></pre>"},{"location":"reference/html-template-tag/#the-update-listener","title":"The <code>@update</code> listener","text":"<p><code>wecco</code> adds a special <code>update</code> event that is invoked everytime this element or parts of it are updated. You can subscribe for this event to apply custom logic when the element updates.</p> <pre><code>const callback = (e: CustomEvent) =&gt; { element = e.target as Element} \nwecco.html`&lt;a @update=${callback}&gt;Hello, world&lt;/a&gt;`\n</code></pre>"}]}