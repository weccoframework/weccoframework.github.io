{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to weccoframework","text":"<p>This site documents the use of <code>@weccoframework/core</code></p> <p><code>weccoframework/core</code> - called <code>wecco</code> - is a web application framework based  on web standards such as Web Components,  HTML Templates  and plain JavaScript that features</p> <ul> <li>simplicity</li> <li>performance</li> <li>small footprint (under 60k uncompressed)</li> </ul> <p><code>wecco</code> features a functional programming style as opposed to a class based  approach using inheritence that other common web frameworks endorse. Using  functions to express a dynamic web UI allows a developer to focus on a  descriptive approach, where as classes tend to obfuscate the concepts behind a dynamic UI.</p> <p><code>wecco</code> provides both a view engine, that renders views based on models as well as a full application framework that is based on the Model, View, Update architecture pattern.</p> <p><code>wecco</code> is written using TypeScript and can be used from TypeScript projects as well as plain JavaScript ones.</p> <p>Besides a couple of development tools (such as TypeScript, mocha, ...) <code>wecco</code> uses no dependencies (all dependencies are declared as <code>devDependencies</code> in the <code>package.json</code>). This means, that adding <code>wecco</code> to your project does not bloat your <code>node_modules</code>.</p> <p> wecco is stil under heavy development and the API is not considered stable until release 1.0.0.</p>"},{"location":"#author","title":"Author","text":"<p>wecco is written by Alexander Metzner alexander.metzner@gmail.com.</p>"},{"location":"#license","title":"License","text":"<pre><code>Copyright (c) 2019 - 2021 The wecco authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> <ul> <li>a web application framework powered by web standards such as web components, custom elements and HTML templates with minimal footprint (less then 60k uncompressed).</li> </ul>"},{"location":"api-reference/","title":"API reference","text":"<p>This page provides a reference to the Javascript API for <code>wecco</code>.</p>"},{"location":"api-reference/#apps","title":"Apps","text":""},{"location":"api-reference/#weccoapp","title":"<code>wecco.app</code>","text":"<p>Creates a new app. The arguments define the app's model, view and update handler as well as the \"mount point\" inside the DOM.</p> <ul> <li><code>modelInitializer</code> - initializer to create the initial model - either synchronously or asynchronously</li> <li><code>updater</code> - applies update messages to the model - either synchronously or asynchronously</li> <li><code>view</code> - renders the model - always synchronously</li> <li><code>mountPoint</code> - the mount point to control using this app</li> </ul> <p>The function returns an <code>AppContext</code> (see below) that can be used to control the app by emitting messages.</p> <pre><code>class Model {\n// ...\n}\ntype Message = // ...\nfunction update(model: Model, message: Message): Model {\n// ...\n}\nfunction view (model: Model, context: wecco.AppContext&lt;Message&gt;) {\n// ...\n}\ndocument.addEventListener(\"DOMContentLoaded\", () =&gt; {\nwecco.app(() =&gt; new Model(), update, view, \"#app\")\n})\n</code></pre>"},{"location":"api-reference/#weccoappcontext","title":"<code>wecco.AppContext</code>","text":"<p>An instance of an <code>AppContext</code> is provided to the <code>view</code> function of an app. The context provides an <code>emit</code> method that can be used to signal a model update by sending a message.</p> <pre><code>interface AppContext&lt;M&gt; {\nemit(message: M): void\n}\n</code></pre>"},{"location":"api-reference/#wecconomodelchange","title":"<code>wecco.NoModelChange</code>","text":"<p>A sentinel value representing the updater's decision not to update the model and skip the re-rendering cycle. May be returned from an <code>update</code> function to indicate that side effects happend (such as updating the storage) but no re-rendering is needed.</p>"},{"location":"api-reference/#custom-elements","title":"Custom Elements","text":""},{"location":"api-reference/#weccodefine","title":"<code>wecco.define</code>","text":"<p><code>define</code> is used to define a new wecco component which is also a custom element. The render callback provided to <code>define</code> will be called whenever the element`s content needs to be updated.</p> <ul> <li><code>name</code> - the name of the custom element. Must follow the custom element specs (i.e. the name must contain a dash)</li> <li><code>renderCallback</code> the render callback</li> <li><code>observedAttributes</code> list of attribute names to observe for changes and bind to data</li> </ul> <p>Returns an instance of a <code>ComponentFactory</code> which can produce instances of the defined component.</p> <pre><code>const CountClicks = wecco.define(\"count-clicks\", (data: CountClicks, context) =&gt; {\ndata.count = data.count ?: 0\nreturn wecco.html`&lt;p&gt;\n        &lt;button class=\"btn btn-primary\" @click=${() =&gt; { data.count++; context.requestUpdate(); }}&gt;\n            You clicked me ${data.count} times\n        &lt;/button&gt;\n    &lt;/p&gt;`\n}, \"count\")\n</code></pre>"},{"location":"api-reference/#weccocomponent","title":"<code>wecco.component</code>","text":"<p>Creates an instance of a <code>define</code>d element which will use the given <code>data</code> and will be added to the given <code>host</code> element. This is an alternative approach to using the <code>ComponentFactory</code> returned by <code>define</code> which does not require a handle to the component factory but uses the browser's built-in registry for custom web components.</p> <p>The following two snippets as essentially the same:</p> <pre><code>const SomeComponent = define(\"some-component\", (data: SomeComponentData, requestUpdate) =&gt; {\n// ..\n})\nSomeComponent({}).mount(\"#body\")\n</code></pre> <p>vs.</p> <pre><code>define(\"some-component\", (data: SomeComponentData, requestUpdate) =&gt; {\n// ..\n})\ncomponent(\"some-component\", SomeComponent({}).mount(\"#body\")\n</code></pre> <ul> <li><code>componentName</code> - the component name</li> <li><code>data</code> - the bound data</li> <li><code>host</code> - the host to add the component to</li> </ul>"},{"location":"api-reference/#rendering-html","title":"Rendering HTML","text":""},{"location":"api-reference/#weccoupdateelement","title":"<code>wecco.updateElement</code>","text":"<p><code>updateElement</code> applies the given update request to the given target.</p> <ul> <li><code>target</code> -  the target to update. This can be a DOM <code>Element</code> or a CSS selector string.</li> <li><code>request</code> - the update \"request\". May be an update function or an <code>ElementUpdater</code>. Usually you will use the return of an <code>wecco.html</code> template string.</li> <li><code>notifyUpdated</code> whether to send an update event after the element update </li> </ul>"},{"location":"api-reference/#weccohtml","title":"<code>wecco.html</code>","text":"<p>Used as a tag for a template string to create an <code>ElementUpdater</code> that updates a DOM node.</p>"},{"location":"api-reference/#weccoshadow","title":"<code>wecco.shadow</code>","text":"<p>Used to create a HTML <code>ShadowDocument</code> to isolate an element from the surrounding CSS and JavaScript.</p>"},{"location":"html-tag-reference/","title":"HTML tag template string reference","text":"<p><code>wecco</code> provides the <code>wecco.html</code> template tag that features easy to use mechanics to render HTML from template strings. The HTML is rendered by the browser using HTML <code>&lt;template&gt;</code> elements that are cached and reused for minimal updates.</p>"},{"location":"html-tag-reference/#element-text","title":"Element text","text":"<p>You can use literal text as well as placeholders to generate literal element text.</p> <pre><code>wecco.html`&lt;p&gt;hello, world!&lt;/p&gt;`\nwecco.html`&lt;p&gt;${\"hello, world!\"}&lt;/p&gt;`\nwecco.html`&lt;p&gt;hello, ${\"world\"}!&lt;/p&gt;`\nconst gretee = \"world\";   wecco.html`&lt;p&gt;Hello&lt;/p&gt;${gretee}`\nwecco.html`&lt;p&gt;${\"hello\"}&lt;/p&gt;${\"world\"}`\nconst message = \"Hello,\";\nconst gretee = \"world\";  wecco.html`&lt;p&gt;${message} ${gretee}!&lt;/p&gt;`\n</code></pre>"},{"location":"html-tag-reference/#attributes","title":"Attributes","text":"<p>You can use placeholders to set the attributes of HTML elements. You can use a single placeholder as the whole attribute's value as well as combine one or more placeholders with literal text.</p> <pre><code>const classes = \"small hero\"\nwecco.html`&lt;p class=${classes}&gt;hello, world!&lt;/p&gt;`\nwecco.html`&lt;p class=\"${classes} hero\"&gt;hello, world!&lt;/p&gt;`\nwecco.html`&lt;p class=\"${classes} hero ${\"col\"}\"&gt;hello, world!&lt;/p&gt;`\n</code></pre>"},{"location":"html-tag-reference/#remove-empty-attributes","title":"Remove empty attributes","text":"<p>If you want to remove an attribute if the placeholder used for the value resolves to <code>null</code>, add a <code>+omitempty</code> suffix to the attribute's name:</p> <pre><code>wecco.html`&lt;p id+omitempty=\"foo ${undefined}\"&gt;&lt;/p&gt;`\n</code></pre>"},{"location":"html-tag-reference/#boolean-attributes","title":"Boolean Attributes","text":"<p>Boolean attributes are attributes with a value that doesn't matter. What matters is whether the attribute is present or not. <code>wecco</code> uses a <code>?</code> prefix for the attribute name. The value must be a single placeholder that will be used in a boolean context.</p> <pre><code>wecco.html`&lt;a ?disabled=${false}&gt;hello, world!&lt;/a&gt;`\n</code></pre>"},{"location":"html-tag-reference/#properties","title":"Properties","text":"<p><code>wecco.html</code> can also set Javascript properties of an <code>HTMLElement</code> created from a template string. A good example for this is setting the <code>value</code> of an input element or the <code>checked</code> attribute of a checkbox.</p> <pre><code>wecco.html`&lt;input type=\"text\" .value=${\"hello, world\"}&gt;`\nwecco.html`&lt;input type=\"checkbox\" .checked=${true} ?disabled=${true}&gt;&lt;input type=\"checkbox\" .checked=${true}&gt;\n</code></pre>"},{"location":"html-tag-reference/#add-event-listeners","title":"Add Event Listeners","text":"<p><code>wecco</code> allows you to add event listeners to <code>HTMLElements</code> created from a template by using the event's name prefixed with <code>@</code> as an attribute. The value must be single placeholder that resolves to a valid JavaScript event handler (usually a function).</p> <pre><code>const callback = () =&gt; { clicked = true }\nwecco.html`&lt;a @click=${callback}&gt;Hello, world&lt;/a&gt;`\n</code></pre> <p>The event attribute name can be suffixed with any of the following suffixes which customize the event listener registration:</p> Suffix Description <code>+capture</code> Sets the <code>capture</code> property of the Options object passed to <code>addEventListener</code> to <code>true</code> <code>+passive</code> Sets the <code>passive</code> property of the Options object passed to <code>addEventListener</code> to <code>true</code> <code>+once</code> Sets the <code>once</code> property of the Options object passed to <code>addEventListener</code> to <code>true</code> <code>+stoppropagation</code> Creates a wrapper for the listener that calls <code>event.StopPropagation()</code> <code>+stopimmediatepropagation</code> Creates a wrapper for the listener that calls <code>event.StopImmediatePropagation()</code> <code>+preventdefault</code> Creates a wrapper for the listener that calls <code>event.PreventDefault()</code> <pre><code>wecco.html`&lt;div @click=${callback.bind(null, \"div\")}&gt;&lt;a @click+stopPropagation=${callback.bind(null, \"a\")}&gt;Hello, world&lt;/a&gt;&lt;/div&gt;`\n</code></pre>"},{"location":"html-tag-reference/#the-update-listener","title":"The <code>@update</code> listener","text":"<p><code>wecco</code> adds a special <code>update</code> event that is invoked everytime this element or parts of it are updated. You can subscribe for this event to apply custom logic when the element updates.</p> <pre><code>const callback = (e: CustomEvent) =&gt; { element = e.target as Element} wecco.html`&lt;a @update=${callback}&gt;Hello, world&lt;/a&gt;`\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p><code>wecco</code> is currently not available from a CDN, so you are required to bundle it with your web application. If you are using <code>npm</code> (or any of the compatible tools, such as <code>pnpm</code> or <code>yarn</code>) you can add <code>wecco</code> as a dependency. This is the recommended way.</p> <p>If you do not use <code>npm</code> you can manually add <code>wecco</code> as a <code>&lt;script&gt;</code> tag to your HTML.</p>"},{"location":"installation/#npm","title":"NPM","text":"<p><code>wecco</code> is available via npm as <code>@weccoframework/core</code>. Simply add it to the <code>dependencies</code> section of your <code>package.json</code>.</p>"},{"location":"installation/#directly-embedding-in-a-html-page","title":"Directly embedding in a HTML page","text":"<p>You can include the a bundled version of <code>wecco</code> into your web application. Simply go to the releases and download the latest version of either the <code>umd</code> or <code>es5</code> bundle. To test a version, you can directly load the bundle from the github downloads, i.e.</p> <pre><code>&lt;script src=\"https://github.com/weccoframework/core/releases/download/v0.21.1/weccoframework-core.es5.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Please note, that this is not recommended for any kind of production systems and should only be used during development.</p>"},{"location":"usage/","title":"Usage","text":"<p>This page gives you an overview of how <code>wecco</code> can be used. This is your page to go especially of you are new to <code>wecco</code>. If you have specific questions concerning the API the JavaScript API has an in-depth reference. For questions on how to write template strings see the  HTML template reference.</p>"},{"location":"usage/#a-wecco-application","title":"A <code>wecco</code> application","text":"<p>The following code contains a full \"app\" for a button that counts the number of times a user clicked it.</p> <pre><code>import * as wecco from \"@weccoframework/core\"\nclass Model {\nconstructor(public readonly count: number) {}\ninc() {\nreturn new Model(this.count + 1)\n}\n}\ntype Message = \"inc\"\nfunction update(model: Model, message: Message): Model {\nreturn model.inc()\n}\nfunction view (model: Model, context: wecco.AppContext&lt;Message&gt;) {\nreturn wecco.html`&lt;p&gt;\n        &lt;button class=\"btn btn-primary\" @click=${() =&gt; context.emit(\"inc\")}&gt;\n            You clicked me ${model.count} times\n        &lt;/button&gt;\n    &lt;/p&gt;`\n}\ndocument.addEventListener(\"DOMContentLoaded\", () =&gt; {\nwecco.app(() =&gt; new Model(0), update, view, \"#count-clicks-app\")\n})\n</code></pre> <p><code>wecco</code> apps use the Model-View-Update architecture pattern. This pattern separates the logic into a model that gets rendered via view functions. Updates to the model happen via a central update function.</p> <p>In the example above the <code>Model</code> class represents the model: a simple counter. Note that <code>inc</code> method the provides the \"business capabilities\" of the model.</p> <p>An instance of the model will be rendered by the <code>view</code> function. This  function is called by <code>wecco</code> with the current model instance and a <code>context</code> which can be used to emit update messages. The view function uses a tagged template string to create the HTML. The template tag <code>wecco.html</code> is very powerful. It compiles the template string into a hidden HTML <code>&lt;template&gt;</code> element and reuses that everytime the view function is executed. While this allows the developer to simple return a template string, under the hood a lot of caching and reusing is happening to only update what is changed.</p> <p>The <code>update</code> function is responsible for executing updates on the model. This function is called by <code>wecco</code> everytime an update <code>Message</code> is emitted. The function receives the current model instance and the message and provides a new (or updated) model reference which will then get rendered again.</p> <p>The call to <code>wecco.app</code> brings these functions together and starts the app. The rendered content will go to the element identified by the CSS expression <code>#count-clicks-app</code>. The first parameter is the \"model initializer\". This function is called once at the very start of the app to produce the initial model. Use this function to implement URL routing or restore a previous model from the local or session storage.</p>"},{"location":"usage/#a-custom-element","title":"A custom element","text":"<p><code>wecco</code> also provides a simple API for defining custom elements. These can be used standalone or as part of an app.</p> <p>Here is the same count clicks example with a custom element:</p> <pre><code>import * as wecco from \"@weccoframework/core\"\ninterface CountClicks {\ncount?: number\n}\nconst CountClicks = wecco.define(\"count-clicks\", (data: CountClicks, context) =&gt; {\ndata.count = data.count ?: 0\nreturn wecco.html`&lt;p&gt;\n        &lt;button class=\"btn btn-primary\" @click=${() =&gt; { data.count++; context.requestUpdate(); }}&gt;\n            You clicked me ${data.count} times\n        &lt;/button&gt;\n    &lt;/p&gt;`\n}, \"count\")\n</code></pre> <p><code>wecco.define</code> is used to define a custom element. It returns a factory function that can be used to create instances of the web component. In addition it registers the custom element's name so that HTML references to the element will be resolved.</p> <p>The first parameter to <code>wecco.define</code> defines the name of the component and must follow the custom webcomponent's conventions (i.e. it must contain a dash).</p> <p>The second parameter is the render callback. The render callback is called everytime the component should update.</p> <p>The first parameter passed to this callback is the component's data. Using Typescript this parameter's type is defined using a generic type parameter. You commonly use an interface to describe the type. </p> <p>The second parameter is the notify update callback. It can be used to notify the component that something has changed and the component should update its content. We use this callback to notify when the user has clicked the button and we updated the <code>data</code>-attribute <code>count</code>.</p> <p>The last line creates an instance of the component passing in an object that implements <code>CountClicks</code> - the data interface - which initializes the  component's data state. The result is an instance of <code>HTMLElement</code> which can be added to the DOM using plain DOM manipulation functions. The object also provides a convenience method <code>mount</code> which can be used to add the element to dom: Simply pass in a <code>HTMLElement</code> or a string which is passed to <code>document.querySelector</code> in order to obtain the element to add the new element as a child.</p> <p>Check out the examples to see these two in action as well as the classical todo app.</p>"}]}